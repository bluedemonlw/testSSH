<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
  <script>
    /*用let关键字声明变量*/
    // 1.同一作用域下,不可重复定义
    let a=10;
    // 2.增加块级作用域:{}内也算一级作用域
    // JS作用域:全局|局部|块级
    for(let i=0;i<3;i++){
      console.log(i);
    }
    // console.log(i);报错,let属于局部变量
    // 3.let声明的局部变量不会提前
    // var声明的变量,变量会被提前到当前作用域的最顶端
    function add1(bool){
      if(!bool){
        let test='hi';
        console.log(test);
      }else{
        // console.log(test);
      }
    }
    add1(true);
    // 4.暂时性死区
    // 在跨级作用域内,使用let声明变量之前,改变变量都不可用,在语法上被称之为暂时性死区
    let tmp=123;
    if(true){
      // tmp='abc';
      let tmp;
      tmp='abc';
      console.log(tmp);
    }
    /*const声明常量,一旦定义,不能修改*/
    const name='lisi';
    console.log(name);
    // name='wz';
    // console.log(name);类型错误
    // 常量定义必须立刻赋值,立刻初始化值,不能留到后面
    /*const age;
    age=20;
    console.log(age);语法错误*/
    // const和let一样,存在暂时性死区,不可重复定义
    /*注意:const实际上保证的是变量指向的地址不变,并不是变量内部的值不可变,值类型的值不可以修改,但引用类型的值可修改,但都不可修改地址*/
    const arr=[1,2,3];
    arr.push(4);
    console.log(arr);
    // 4.let,const这两种声明方式在全局作用域下不会被添加到window对象上
    // let bbb='abc';undefined
    var aaa='abc';
    console.log(window.aaa,window.bbb);
  </script>
</body>
</html>